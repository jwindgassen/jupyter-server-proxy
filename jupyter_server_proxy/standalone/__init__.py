import argparse
import logging
import os

from tornado import ioloop
from tornado.httpserver import HTTPServer
from tornado.log import app_log

from .proxy import (
    configure_http_client,
    get_port_from_env,
    get_ssl_options,
    make_app,
    start_keep_alive,
)


def run(
    command: list[str],
    port=None,
    destport=0,
    ip="localhost",
    debug=False,
    logs=True,
    authtype="oauth",
    request_timeout=300,
    last_activity_interval=300,
    force_alive=True,
    forward_user_info=False,
    query_user_info=False,
    progressive=False,
    websocket_max_message_size=0,
):
    if port is None:
        get_port_from_env()

    if debug:
        app_log.setLevel(logging.DEBUG)
    elif logs:
        app_log.setLevel(logging.INFO)

    prefix = os.environ.get("JUPYTERHUB_SERVICE_PREFIX", "/")

    if len(prefix) > 0 and prefix[-1] == "/":
        prefix = prefix[:-1]

    configure_http_client()

    app = make_app(
        destport,
        prefix,
        list(command),
        authtype,
        request_timeout,
        debug,
        logs,
        forward_user_info,
        query_user_info,
        progressive,
        websocket_max_message_size,
    )

    ssl_options = get_ssl_options()

    http_server = HTTPServer(app, ssl_options=ssl_options, xheaders=True)

    http_server.listen(port or get_port_from_env(), ip)

    print(
        f"Starting jhsingle-native-proxy server on address {ip} port {port}, proxying to port {destport}"
    )
    print(f"URL Prefix: {prefix}")
    print(f"Auth Type: {authtype}")
    print(f"Command: {command}")

    if last_activity_interval > 0:
        start_keep_alive(last_activity_interval, force_alive, app.settings)

    ioloop.IOLoop.current().start()


def main():
    parser = argparse.ArgumentParser(
        "jupyter-native-proxy",
        description="Wrap an arbitrary WebApp so it can be used in place of 'singleuser' in a JupyterHub setting",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--port",
        default=None,
        type=int,
        help="Port for the proxy server to listen on. Defaults to JupyterHub default.",
    )
    parser.add_argument(
        "--destport",
        default=0,
        type=int,
        help="Port for the WebApp should end up running on. Leave at 0 for a random open port.",
    )
    parser.add_argument("--ip", default="localhost", help="Address to listen on.")
    parser.add_argument(
        "--debug", action="store_true", default=False, help="Display debug level logs."
    )
    parser.add_argument(
        "--logs",
        action="store_true",
        default=True,
        help="Display logs generated by the subprocess.",
    )
    parser.add_argument(
        "--authtype",
        choices=["oauth", "none"],
        default="oauth",
        help="Authentication Metod.",
    )
    parser.add_argument(
        "--request-timeout",
        default=300,
        type=int,
        help="Timeout for proxied HTTP calls to subprocess in seconds.",
    )
    parser.add_argument(
        "--last-activity-interval",
        default=300,
        type=int,
        help="Frequency to notify Hub that the WebApp is still running in seconds. 0 for never.",
    )
    parser.add_argument(
        "--force-alive",
        action="store_true",
        default=True,
        help="Always report, that there has been activity (force keep alive) - only if last-activity-interval > 0.",
    )
    parser.add_argument(
        "--forward-user-info",
        action="store_true",
        default=False,
        help="Forward a 'X-CDSDASHBOARDS-JH-USER' HTTP header to process containing JupyterHub user data.",
    )
    parser.add_argument(
        "--query-user-info",
        action="store_true",
        default=False,
        help="Add a 'CDSDASHBOARDS_JH_USER GET' query arg in HTTP request to process containing JupyterHub user data.",
    )
    parser.add_argument(
        "--progressive",
        action="store_true",
        default=False,
        help="Progressively flush responses as they arrive (good for Voila).",
    )
    parser.add_argument(
        "--websocket-max-message-size",
        default=0,
        type=int,
        help="Max size of websocket data (leave at 0 for library defaults).",
    )
    parser.add_argument(
        "command", nargs="+", help="The command executed for starting the WebApp"
    )

    args = parser.parse_args()
    run(**vars(args))


if __name__ == "__main__":
    main()
