import argparse
import logging
import os

from tornado import ioloop
from tornado.httpserver import HTTPServer
from tornado.log import app_log as log

from .activity import start_activity_update
from .proxy import configure_http_client, get_port_from_env, get_ssl_options, make_app


def run(
    command,
    port,
    destport,
    ip,
    debug,
    logs,
    overwrite_authentication,
    timeout,
    activity_interval,
    progressive,
    websocket_max_message_size,
):
    if port is None:
        get_port_from_env()

    if debug:
        log.setLevel(logging.DEBUG)
    elif logs:
        log.setLevel(logging.INFO)

    prefix = os.environ.get("JUPYTERHUB_SERVICE_PREFIX", "/")

    if len(prefix) > 0 and prefix[-1] == "/":
        prefix = prefix[:-1]

    configure_http_client()

    app = make_app(
        destport,
        prefix,
        list(command),
        overwrite_authentication,
        timeout,
        debug,
        logs,
        progressive,
        websocket_max_message_size,
    )

    ssl_options = get_ssl_options()

    http_server = HTTPServer(app, ssl_options=ssl_options, xheaders=True)

    http_server.listen(port or get_port_from_env(), ip)

    log.info(
        f"Starting standaloneproxy on {ip}:{port}, server is started on Port {destport}"
    )
    log.info(f"URL Prefix: {prefix}")
    log.info(f"Command: {command}")

    if activity_interval > 0:
        start_activity_update(activity_interval)

    ioloop.IOLoop.current().start()


def main():
    parser = argparse.ArgumentParser(
        "jupyter-native-proxy",
        description="Wrap an arbitrary WebApp so it can be used in place of 'singleuser' in a JupyterHub setting",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--port",
        default=None,
        type=int,
        help="Port for the proxy server to listen on. Defaults to JupyterHub default.",
    )
    parser.add_argument(
        "--destport",
        default=0,
        type=int,
        help="Port for the WebApp should end up running on. Leave at 0 for a random open port.",
    )
    parser.add_argument("--ip", default="localhost", help="Address to listen on.")
    parser.add_argument(
        "--debug", action="store_true", default=False, help="Display debug level logs."
    )
    parser.add_argument(
        "--logs",
        action="store_true",
        default=True,
        help="Display logs generated by the subprocess.",
    )
    parser.add_argument(
        "--overwrite-authentication",
        default=None,
        help="Forcefully enable/disable authentication with JupyterHub.",
    )
    parser.add_argument(
        "--timeout",
        default=60,
        type=int,
        help="Timeout to wait until the subprocess has started and can be addressed.",
    )
    parser.add_argument(
        "--activity-interval",
        default=300,
        type=int,
        help="Frequency to notify Hub that the WebApp is still running (In seconds, 0 for never).",
    )
    parser.add_argument(
        "--progressive",
        action="store_true",
        default=False,
        help="Progressively flush responses as they arrive (good for Voila).",
    )
    parser.add_argument(
        "--websocket-max-message-size",
        default=0,
        type=int,
        help="Max size of websocket data (leave at 0 for library defaults).",
    )
    parser.add_argument(
        "command", nargs="+", help="The command executed for starting the WebApp"
    )

    args = parser.parse_args()
    log.debug(args)

    run(**vars(args))


if __name__ == "__main__":
    main()
