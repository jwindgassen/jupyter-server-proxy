import argparse
import logging
import os

from tornado import ioloop
from tornado.httpserver import HTTPServer
from tornado.log import app_log as log
from tornado.log import enable_pretty_logging

from .activity import start_activity_update
from .proxy import get_port_from_env, make_proxy_app


def _use_jupyterhub(overwrite):
    """
    Try to determine if we are launched by a JupyterHub via the environment variables.
    See jupyterhub/spawner.py#L1035
    """
    if overwrite is not None:
        return overwrite

    return "JUPYTERHUB_API_TOKEN" in os.environ and "JUPYTERHUB_API_URL" in os.environ


def run(
    command,
    port,
    destport,
    ip,
    debug,
    # logs,
    overwrite_authentication,
    timeout,
    activity_interval,
    # progressive,
    websocket_max_message_size,
):
    if port is None:
        port = get_port_from_env()

    enable_pretty_logging(logger=log)
    if debug:
        log.setLevel(logging.DEBUG)

    use_jupyterhub = _use_jupyterhub(overwrite_authentication)
    if use_jupyterhub:
        log.info("Enabling Authentication with JupyterHub")

    prefix = os.environ.get("JUPYTERHUB_SERVICE_PREFIX", "/")

    app = make_proxy_app(
        destport,
        prefix.removesuffix("/"),
        list(command),
        use_jupyterhub,
        timeout,
        debug,
        # progressive,
        websocket_max_message_size,
    )

    ssl_options = None
    if use_jupyterhub:
        from .hub import configure_ssl

        ssl_options = configure_ssl()

    http_server = HTTPServer(app, ssl_options=ssl_options, xheaders=True)
    http_server.listen(port, ip)

    log.info(f"Starting standaloneproxy on {ip}:{port}")
    log.info(f"URL Prefix: {prefix!r}")
    log.info(f"Command: {command}")

    # Periodically send JupyterHub Notifications, that we are still running
    if use_jupyterhub and activity_interval > 0:
        log.info(
            f"Sending Acitivity Notivication to JupyterHub with interval={activity_interval}"
        )
        start_activity_update(activity_interval)

    ioloop.IOLoop.current().start()


def main():
    parser = argparse.ArgumentParser(
        "jupyter-native-proxy",
        description="Wrap an arbitrary WebApp so it can be used in place of 'singleuser' in a JupyterHub setting",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--port",
        default=None,
        type=int,
        help="Port for the proxy server to listen on. Defaults to JupyterHub default.",
    )
    parser.add_argument(
        "--destport",
        default=0,
        type=int,
        help="Port for the WebApp should end up running on. Leave at 0 for a random open port.",
    )
    parser.add_argument("--ip", default="localhost", help="Address to listen on.")
    parser.add_argument(
        "--debug", action="store_true", default=False, help="Display debug level logs."
    )
    # ToDo: Split Server and Application Logger
    # parser.add_argument(
    #     "--logs",
    #     action="store_true",
    #     default=True,
    #     help="Display logs generated by the subprocess.",
    # )
    parser.add_argument(
        "--overwrite-authentication",
        default=None,
        type=lambda v: None if v is None else bool(v),
        help="Forcefully enable/disable authentication with JupyterHub.",
    )
    parser.add_argument(
        "--timeout",
        default=60,
        type=int,
        help="Timeout to wait until the subprocess has started and can be addressed.",
    )
    parser.add_argument(
        "--activity-interval",
        default=300,
        type=int,
        help="Frequency to notify Hub that the WebApp is still running (In seconds, 0 for never).",
    )
    # ToDo: Progressive Proxy
    # parser.add_argument(
    #     "--progressive",
    #     action="store_true",
    #     default=False,
    #     help="Progressively flush responses as they arrive (good for Voila).",
    # )
    parser.add_argument(
        "--websocket-max-message-size",
        default=0,
        type=int,
        help="Max size of websocket data (leave at 0 for library defaults).",
    )
    parser.add_argument(
        "command", nargs="+", help="The command executed for starting the WebApp"
    )

    args = parser.parse_args()
    run(**vars(args))


if __name__ == "__main__":
    main()
